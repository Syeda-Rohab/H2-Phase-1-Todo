# Data Model: Console CRUD Todo Application

**Feature**: 001-console-todo-crud
**Date**: 2025-12-26
**Status**: Final

## Entity: Task

### Overview
Represents a single todo item with all required metadata for CRUD operations and persistence.

### Attributes

| Attribute | Type | Required | Default | Constraints | Description |
|-----------|------|----------|---------|-------------|-------------|
| `id` | `int` | Yes | Auto-generated | > 0, unique | Unique identifier, auto-incremented starting from 1 |
| `title` | `str` | Yes | - | 1-500 chars | Short description of the task |
| `description` | `str` | Yes | Empty string | 0-2000 chars | Detailed notes or context |
| `completed` | `bool` | Yes | `False` | True/False | Completion status |
| `created_at` | `str` | Yes | Auto-generated | ISO 8601 format | UTC timestamp when task was created |

### Validation Rules

1. **ID Uniqueness**: IDs must be unique across all tasks. Generated by finding max(existing_ids) + 1.
2. **Title Required**: Title cannot be empty or whitespace-only when creating/updating tasks.
3. **Title Length**: Title must be between 1-500 characters (prevents UI display issues).
4. **Description Optional**: Description can be empty string but not None.
5. **Description Length**: Description limited to 2000 characters (reasonable for console display).
6. **Timestamp Format**: `created_at` must be valid ISO 8601 (YYYY-MM-DDTHH:MM:SS±HH:MM or YYYY-MM-DDTHH:MM:SSZ).
7. **Immutable Fields**: `id` and `created_at` cannot be changed after creation.

### State Transitions

```
[New Task]
    ↓ (add command with title + description)
[Active Task: completed=False]
    ↓ (complete command)
[Completed Task: completed=True]
    ↓ (incomplete command)
[Active Task: completed=False]
    ↓ (delete command)
[Deleted] (removed from storage)
```

**Valid Transitions**:
- `False → True` via `complete` command
- `True → False` via `incomplete` command
- `Any → Deleted` via `delete` command
- `Any → Updated` via `update` command (title/description only)

### Python Dataclass Definition

```python
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from typing import Dict

@dataclass
class Task:
    """Represents a todo task with CRUD operations support."""

    id: int
    title: str
    description: str
    completed: bool
    created_at: str

    def to_dict(self) -> Dict[str, any]:
        """Convert task to dictionary for JSON serialization."""
        return asdict(self)

    @staticmethod
    def from_dict(data: Dict[str, any]) -> 'Task':
        """Create task from dictionary (JSON deserialization)."""
        return Task(
            id=int(data['id']),
            title=str(data['title']),
            description=str(data['description']),
            completed=bool(data['completed']),
            created_at=str(data['created_at'])
        )

    def validate(self) -> None:
        """Validate task data meets constraints."""
        if not self.title or not self.title.strip():
            raise ValueError("Title cannot be empty")
        if len(self.title) > 500:
            raise ValueError("Title cannot exceed 500 characters")
        if len(self.description) > 2000:
            raise ValueError("Description cannot exceed 2000 characters")
        if self.id <= 0:
            raise ValueError("ID must be positive integer")

def create_task(task_id: int, title: str, description: str) -> Task:
    """Factory function to create a new task with auto-generated timestamp."""
    now = datetime.now(timezone.utc).isoformat()
    task = Task(
        id=task_id,
        title=title.strip(),
        description=description.strip(),
        completed=False,
        created_at=now
    )
    task.validate()
    return task
```

### JSON Storage Format

Tasks are stored as a JSON array in `data/tasks.json`:

```json
[
  {
    "id": 1,
    "title": "Design mockups",
    "description": "Create wireframes for login page",
    "completed": false,
    "created_at": "2025-12-26T14:30:00Z"
  },
  {
    "id": 2,
    "title": "Review code",
    "description": "",
    "completed": true,
    "created_at": "2025-12-26T15:45:00Z"
  }
]
```

**Format Rules**:
- Root element is array (allows empty list `[]` for no tasks)
- Each task is JSON object with all 5 attributes
- No null values (use empty string for description)
- 2-space indentation for readability
- UTF-8 encoding

### Storage Operations

**Load Tasks**:
```python
def load_tasks() -> list[Task]:
    """Load all tasks from JSON file."""
    try:
        with open('data/tasks.json', 'r', encoding='utf-8') as f:
            data = json.load(f)
            return [Task.from_dict(t) for t in data]
    except FileNotFoundError:
        return []
    except json.JSONDecodeError as e:
        print(f"Warning: Corrupted data file. Starting fresh. ({e})")
        return []
```

**Save Tasks** (atomic write):
```python
def save_tasks(tasks: list[Task]) -> None:
    """Save all tasks to JSON file atomically."""
    import os
    from pathlib import Path

    Path('data').mkdir(exist_ok=True)
    temp_file = 'data/tasks.tmp.json'
    final_file = 'data/tasks.json'

    # Write to temp file
    with open(temp_file, 'w', encoding='utf-8') as f:
        json.dump([t.to_dict() for t in tasks], f, indent=2, ensure_ascii=False)

    # Atomic rename
    os.replace(temp_file, final_file)
```

## Relationships

No relationships - this is a single-entity system. Tasks are independent and have no parent/child or reference relationships.

## Indexing Strategy

For console application with <1000 tasks, no indexing needed:
- **By ID**: Linear search O(n) is acceptable for small dataset
- **All tasks**: Load entire file into memory (simple, fast for this scale)

If scaling beyond 1000 tasks, consider:
- In-memory dictionary: `{id: Task}` for O(1) lookup
- SQLite with indexed id column

## Data Integrity

**Constraints Enforced**:
1. Unique IDs (enforced by generation logic, not storage layer)
2. Non-null fields (enforced by dataclass and validation)
3. Valid timestamps (enforced by datetime library)

**Error Recovery**:
- Corrupted JSON → Start with empty task list, log warning
- Missing file → Create new file with empty array
- Invalid task data → Skip malformed task, log warning, load others

**Backup Strategy** (future enhancement):
- Before each save, keep previous version as `tasks.json.bak`
- Allows manual recovery if data corruption detected

## Performance Characteristics

**Load Time**: O(n) where n = number of tasks
- Expected: <10ms for 100 tasks, <100ms for 1000 tasks

**Save Time**: O(n) for serialization + O(1) for atomic file write
- Expected: <50ms for 100 tasks, <500ms for 1000 tasks

**Memory Usage**: O(n) - entire task list in memory
- Expected: ~1KB per task → 1MB for 1000 tasks (negligible)

## Migration Strategy

**Version 1.0** (current):
- Initial schema with 5 fields

**Future Versions** (out of scope, documented for reference):
- Add `updated_at` field → Default to `created_at` for existing tasks
- Add `priority` field → Default to 0 (normal) for existing tasks
- Add `tags` array → Default to `[]` for existing tasks

**Migration Pattern**:
```python
def migrate_task_v1_to_v2(task_dict: Dict) -> Dict:
    """Example migration adding updated_at field."""
    if 'updated_at' not in task_dict:
        task_dict['updated_at'] = task_dict['created_at']
    return task_dict
```

## Testing Checklist

- [ ] Create task with all fields
- [ ] Create task with empty description
- [ ] Validate title length limits (1-500 chars)
- [ ] Validate description length limits (0-2000 chars)
- [ ] Verify ID auto-generation (1, 2, 3, ...)
- [ ] Verify timestamp is ISO 8601 UTC
- [ ] Verify completed defaults to False
- [ ] Load tasks from file
- [ ] Save tasks to file (atomic write)
- [ ] Handle missing file gracefully
- [ ] Handle corrupted JSON gracefully
- [ ] Verify task serialization/deserialization round-trip
